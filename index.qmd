---
title: "Monte Carlo Simulation"
author: "Ryan Barent"
format: html
---


(Adapted from Monte Carlo Simulation: An Introduction for Engineers and Scientists by Alan Stevens, Chapter 11)

Polymers are large molecules comprised of a large number of repeated units (monomers) linked end to end. 
There are naturally occurring polymers, such as cellulose, and artificial polymers, such as polythene (polyethylene). 
A simple model of a polymer assumes its linked units are each oriented completely randomly with respect to each other. 
This results in a nearly infinite number of configurations.

Suppose the goal is to estimate the straight-line distance between the start and end of the polymer chain. 
The theoretical probability density function for this distance is $$P(R) = 4\pi R^2\left(\frac{3}{2\pi\langle r^2\rangle}\right)^{3/2}\exp\left(-\frac{3R^2}{2\langle r^2\rangle}\right), $$
where $R$ is the end-to-end distance, and the mean square position of the units is $\langle r^2\rangle = N u^2$ where $N$ is the number of units in the chain and $u$ is ithe length of each unit. 
For simplicity, we'll work with $u=1$. 


# Unconstrained Polymer Chains

The position of each link of the chain relative to the previous link can be described with angles $\theta\in[0,2\pi]$ and $\phi\in[0,pi]$ (think of $\theta$ as describing the direction in the XY plane and $\phi$ as describing the direction in the plane uniquely defined by the points $(0,0,0)$, $(x, y, 0)$, and $(x, y, z)$). In this case, $\phi$ need only cover $\pi$ radians. 

Without loss of generality, we can assume that the chain starts at the origin. 
Then, the end point in the chain can be described by a cumulative sum of a series of x, y, and z coordinates that are a function of $\theta_{n\times 1}$ and $\phi_{n\times 1}$:

$$\begin{array}{rcl} x &=& \cos(\theta)\sin(\phi)\\
y &=& \sin(\theta)\sin(\phi)\\
z &=& \cos(\phi)\end{array} $$

The distance between the origin and the end of the chain $(x,y,z)$ can be calculated as $\sqrt{x^2 + y^2 + z^2}$. 


## Single Unconstrained Link Function

Write a function that takes $n$ and returns the distance between the start and end points of a chain. 
Use vector-based operations to increase the efficiency of your function.


```{r}
distcalc = function(n){
theta = runif(n, 0, 2*pi)
phi = runif(n, 0, 2*pi)
    
x = cos(theta)*sin(phi)
y = sin(theta)*sin(phi)
z = cos(phi)

x_fin = sum(x)
y_fin = sum(y)
z_fin = sum(z)

dist = sqrt(x_fin^2 + y_fin^2 + z_fin^2)
return(dist)
  
}

distcalc(10)



```

## Distribution of Unconstrained Links

Simulate 10000 chains and save the distribution of the end-to-end distance.

```{r}
library(ggplot2)

results = data.frame(value = replicate(1000, distcalc(10)))

ggplot(results, aes(x = value)) + geom_histogram(bins = 30)

```

# Constrained Polymer Chains
For real polymers, adjacent links don’t have the complete freedom of orientation allowed in the case of the ideal model. 
We can simulate a simple constrained orientation model by restricting the relative orientation of adjacent links.
We’ll prevent adjacent links from orienting themselves such that there is an acute angle smaller than, say 45° between them. 
We can do this by checking the angle between adjacent links after choosing a random orientation and repeatedly choosing the random orientation until that angle is larger than 45°.


## Single Constrained Link Function

Write a function that takes $n$ and returns the distance between the start and end points of a chain. 
Can you think of a way to use vectorized functions to accomplish this task? Why or why not?

```{r}
constrained = function(n){
  

  
  x_vec = c(0)
  y_vec = c(0)
  z_vec = c(0)
  
  tx = 0
  ty = 0
  tz = 0
    
  ox = 0
  oy = 0
  oz = 0
  
  for (i in 1:n){
  dist = 0
  while (dist<0.765){
    
    theta = runif(1, 0, 2*pi)
    phi = runif(1, 0, 2*pi)

    
    x = cos(theta)*sin(phi)
    y = sin(theta)*sin(phi)
    z = cos(phi)
    
    dist = sqrt((x-tx)^2 + (y-ty)^2 + (z-tz)^2)
  }
    
  x_vec = c(x_vec,x)
  y_vec = c(y_vec,y)
  z_vec = c(z_vec,z)
  
  tx = ox
  ty = oy
  tz = oz
  
  ox = x
  ty = y
  tz = z
  
  }    
dist_total = sqrt(sum(x_vec)^2 + sum(y_vec)^2 + sum(z_vec)^2)
return(dist_total)

}

constrained(10)
```

## Distribution of Constrained Links

Simulate 10000 chains and save the distribution of the end-to-end distance.
Plot the density of the unconstrained links and the density of constrained links on the same plot -- how much has the distribution changed?

```{r}
results_constrained = data.frame(value = replicate(1000,constrained(10)))

ggplot() +
  geom_histogram(data = results, aes(x = value, fill = "Unconstrained"),bins = 30,color = "black",) +
  geom_histogram(data = results_constrained,aes(x = value, fill = "Constrained"),bins = 30,color = "black",) +
  scale_fill_manual(name = "Type",values = c("Unconstrained" = "blue","Constrained"   = "red" )
  )



```


